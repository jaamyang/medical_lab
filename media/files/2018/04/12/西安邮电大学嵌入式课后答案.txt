


嵌入式系统开发 习题1 1.什么是嵌入式系统？有何特点？  答：嵌入式系统的概念有很多种，在嵌入式系统领域中比较认同的嵌入式系统的概念是：嵌入式系统是以应用为中心，以计算机技术为基础，并且软硬件可裁剪，适用于应用系统对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统。 嵌入式系统的特点： ⑴ 嵌入式系统是将先进的计算机技术、半导体技术以及电子技术与各个行业的具体应用相结合的产物，这一点就决定了它必然是一个技术密集、资金密集、高度分散、不断创新的知识集成系统。 ⑵ 系统内核小。由于嵌入式系统一般是应用于小型电子装置中，系统资源相对有限，所以内核较之传统的操作系统要小得多。 ⑶ 专用性强。 ⑷ 系统精简。 ⑸ 系统软件（OS）要求具有高实时性。 ⑹ 嵌入式软件开发要走向标准化，需要使用多任务的操作系统。 ⑺ 嵌入式系统本身并不具备在其上进行进一步开发的能力。 2.嵌入式系统可以分为几层？每一层各完成哪些功能？  答：嵌入式系统由硬件层、中间层、软件层和功能层组成。  硬件层：以嵌入式微处理器为核心，存储器用以存储数据和执行代码，相关的设备接口和I/O接口，这些组成了一个嵌入式系统的基础，实现逻辑运算，算术运算等。 中间层：将系统上层软件和底层硬件进行分离，封装成标准的接口，在上层软件开发人员无需知道底层硬件的具体情况，完成的任务是底层硬件的初始化、数据的输入/输出操作、硬件的配置等功能。 软件层：主要由RTOS、文件系统、图形用户接口、网络系统和通用的组件模块组成，是软件开发的基础。 功能层：用来完成被控对象的控制功能。 3.嵌入式系统中硬件抽象层有什么特点？   答：硬件抽象层是介于硬件层与软件层之间的中间层，它将系统上层软件与底层硬件分离开来，具有以下两个特点： ⑴ 硬件相关性：因为嵌入式实时系统的硬件环境具有应用相关性，而作为上层软件与硬件平台之间的接口，硬件抽象层需要为操作系统提供操作和控制具体硬件的方法。 ⑵ 操作系统相关性：不同的操作系统具有各自的软件层次结构，因此，不同的操作系统具有特定的硬件接口形式。 4.简述嵌入式处理器的硬件组成？   答：随着集成电路集成度的不断提高，嵌入式系统板级的硬件电路模块也越来越多的集成到芯片内部，目前处理器芯片内部的电路模块组成如下： ⑴ 处理器内核，以CPU为核心，有的还包含MMU（存储器管理单元）、Cache（高速缓存）、ICE（在线仿真）等电路模块。 


⑵ DSP/协处理器，对于多媒体处理的处理器，内部一般有DSP（数字信号处理）、浮点运算、图像加速等协处理器。 ⑶ RAM/ROM，在单片机处理器中，处理器芯片内部一般集成了ROM（只读存储器）和RAM（可读可写存储器）。 ⑷ 处理器内部控制电路，如PLL（锁相环）、复位、DMA（直接存储器存取）、中断控制器、低功耗控制、看门狗等电路。 ⑸ 芯片内部接口电路，如GPIO（通用输入、输出）接口、I2C（双向两线制的串行总线）接口、IIS（音频总线）接口、SPI（串行外设接口）、USB（通用串行总线）接口、LCD（液晶显示）接口、ADC/DAC（模数/数模转换）、UART（通用异步收发器）、IrDA（红外接口）、CAN（控制器局域网络）总线接口、以太网接口、Timer/RTC（定时器/计数器）接口等电路模块。 5.嵌入式处理器分那几类？它们有何特点？ 答：⑴嵌入式微处理器。特点：处理能力强，具有较高的性能，价格也相应较高。 ⑵ 嵌入式微控制器。特点：主要用于嵌入式体统工业的主流，跟嵌入式微处理器相比，微控制器的最大特点是单片化，体积大大减小，从而使功耗和成本下降，可靠性提高。并且价格低廉，功能优良，拥有的品种和数量最多。 ⑶ 嵌入式DSP处理器。特点：DSP处理器是专门用于信号处理方面的处理器，在系统结构和指令算法方面进行了特殊设计，具有很高的编译效率和指令的执行速度。 ⑷ SoC片上系统。特点：①实现了软硬件无缝结合，直接在处理器片内嵌入操作系统的代码模块 ②具有极高的综合性，在一个硅片内部运用VHDL等硬件描述语言，实现一个复杂的系统 ③绝大部分系统构件在系统内部，系统简洁，减少了系统的体积和功耗，提高了系统的可靠性跟设计生产效率。 6.分析目前市场上常用的几种嵌入式处理器，说明不同嵌入式处理器的各自特点？   答：目前市场上常用的嵌入式处理器有MCS51单片机，ARM处理器，MIPS处理器，PowerPC处理器，MC68000处理器，X86处理器等。 MCS51的特点是，8位CPU，片内振荡器，4KB ROM ,128KB RAM,21个特殊功能寄存器，32根I/O总线，片外可寻找范围分别为64KB的外部程序和数据，两个16位的定时/计数器，一个全双工串口接口，中断结构分为两级优先级，5个中断源，适于按位逻辑运算的处理器。 ARM处理器的特点是，体积小，功耗低，成本低，高性能，支持16/32位双指令集，在全球有众多合作伙伴。 MIPS处理器的特点是，高性能，高档次的处理器，有32位和64位的处理器，简化硬件设计，强调软硬件协同提高性能。 PowerPC处理器特点，具有优异的性能，低能量消耗，低散热量。 MC68000处理器，是一个16/32位的CISC处理器，采用32位总线和寄存器，这个结构对之后的32为产品保持兼容。 X86处理器的特点，可变指令长度的CISC处理器，允许不对齐访问存储器。 7.举例说明嵌入式处理器的性能指标？并分析对嵌入式系统的影响？   答：性能指标主要有主频，处理器字长，数据通路速度，运算速度，高速缓存和处理器的系统架构。主频，执行每条指令的时钟周期数一定，主频越高单位时间内执行的指令越多。处理器字长，处理器内部数据运算的基本位数，反映的是计算精度，以及单次处理数据的总长度；数据通路速度，读取指令数据传输计算数据的速度越高，处理器性能越好。运算


速度，用MIPS（每秒执行多少百万条指令）表示，MIPS越大，说明运算速度越快；高速缓存，突破主存访问速度的瓶颈，提高处理器的综合性能。 8.简述你对嵌入式操作系统的认识，分析嵌入式操作系统有哪些特点？   答：嵌入式操作系统EOS是一种支持嵌入式系统应用的操作系统软件，它是嵌入式系统（包括软硬件系统）极为重要的组成部分，通常包括与硬件相关的底层驱动软件、系统内核、设备驱动接口、通信协议、图形界面、标准化浏览器等。    EOS是相对于一般操作系统而言的，它除具备了一般操作系统最基本的功能，如任务调度、同步机制、中断处理、文件功能等之外，还有以下特点： ⑴ 可装卸性，开放性、可伸缩性的体系结构。 ⑵ 强实时性，EOS实时性一般较强，可用于各种控制系统中。 ⑶ 统一的接口，提供各种设备驱动接口。 ⑷ 操作方便、简单，提供友好的图形GUI，追求易学易用。 ⑸ 提供强大的网络功能，支持TCP/IP协议及其他协议，提供TCP/UDP/IP/PPP协议支持及统一的MAC访问层接口，为各种移动计算设备预留接口。 ⑹ 强稳定性，弱交互性。 ⑺ 固化代码。 ⑻ 更好地硬件适应性，也就是良好的移植性。 9.试分析实时操作系统中可抢占型和不可抢占型有何区别？并举例说明。   答：实时操作系统可分为可抢占型和不可抢占型两类。对于基于优先级的系统而言，可抢占型的实时操作系统是指内核可以抢占正在运行任务的CPU使用权并将使用权交给进入就绪态的优先级更高的任务，是内核抢了CPU让别的任务运行。不可抢占型实时操作系统使用某种算法以决定让某个任务运行后，就把CPU的控制权完全交给该任务，直到它主动将CPU控制权还回来。 比如嵌入式操作系统uC/OS，可以根据优先级进行抢占使用CPU，优先级高的任务可以比优先级低的任务优先使用CPU。 10.简述嵌入式系统的开发过程？   答：嵌入式系统的开发过程可以分为需求分析、建立开发环境、体系结构设计、软件/硬件设计、系统集成和系统优化与测试6个阶段。如果设计的流程是从需求分析开始，然后是建立开发环境，依次进行，最后是系统优化与测试，那么就叫做自上而下的设计流程；反之就叫做自下而上的设计流程。所有的嵌入式系统设计不可避免的设计这六个阶段，更重要的是找到一个好的设计方法，目前一种比较好的设计方法是采用计算机辅助设计工具。 11. 简述在线仿真器ICE和在线调试器ICD有何区别？   答：在线仿真器ICE是一种模拟CPU的设备，能执行CPU的全部动作。采用该方式调试时，利用仿真头代替目标板上的CPU，可以完全仿真CPU的行为。     在线调试器ICD是将CPU的调试功能的引脚引出来，让外部的硬件直接连接到这些引脚上去监控整个CPU的动作。 12. 试分析嵌入式系统测试中的纯软件测试过程，举例说明实现方法。   答：纯软件测试过程是指用工具采用软件打点技术，在被测试代码中加入一些函数，这些函数用来完成数据的生成，并将数据送往目标机系统的共享内存中，同时，在目标机系统中运行一个与处理任务，用于完成这些数据的预处理，然后将处理过的数据通过目标机的串口，网口或者USB口送往宿主机测试平台。举例，可以在程序中间插入函数，读出当前所有寄存器内容，发送至目标机系统，测试者可以根据这些数据了解系统执行情况。 


习题2 1. 按照ARM处理器的命名规则，说明ARM7TDMI中T、D、M、I的含义。   答：T：支持16位的Thumb指令集；D：支持JTAG片上调试；M：支持长乘法操作（64位结果）的ARM指令，包含快速乘法器；I：带有嵌入式追踪宏单元ETM（Embedded Trace Macro），用来设置断点和观察点。 2. 什么是哈佛结构？与普林斯顿结构有何区别？   答：哈佛结构是一种将程序中指令和数据分开存储的存储器结构。即哈佛结构中程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问。      普林斯顿结构（冯・诺伊曼结构）是一种将程序指令存储器和数据存储器合并在一起的存储器结构。程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置。这便是。这便是两种结构的区别。 3. 什么是RSIC？什么是CSIC？简述他们的特点与差别。   答：RSIC是精简指令集计算机，CISC是复杂指令集计算机。两者的区别在于不同的CPU设计理念和方法。 对于CISC：⑴ 在CSIC结构的指令系统中，各种指令的使用频率相差悬殊。有80%的指令只在20%的运行时间内才会用到。 ⑵ CISC结构指令系统的复杂性带来了计算机体系结构的复杂性，这不仅增加了研制时间和成本，而且还容易造成设计错误。 ⑶ 在CISC结构指令系统中，由于各条指令的功能不均衡性，不利于采用先进的计算机体系结构技术来提高系统的性能。 对于RISC：⑴ 简化指令集，只保留常用的基本指令； ⑵ 设计大量的通用存储器，减少访存的次数； ⑶ 采用装载/保存结构，支持流水线技术，使每个周期时间相等； ⑷ 采用简单的指令格式、规整的指令字长和简单的寻址方式； ⑸ 单机器周期指令，即大多数的指令都可以在一个机器周期内完成，并且允许处理器在同一时间内执行一系列的指令。 4. ARM7处理器是几级流水线？在ARM7处理器中，“PC指向的是下一条要执行的指令”，这句话对吗？为什么？   答：ARM7处理器采用三级流水线。 DPC指向的是下一条要执行的指令‖，这句话不对。在ARM处理器中将PC程序计数器定义到R15寄存器，无论处理器处于何种状态，PC总是指向D正在取值‖指令的地址，一般来说，人们习惯性的约定将D正在执行的指令作为参考点‖，成为当前第一条指令，那么PC总是指向随后的第三条指令，或者说PC总是指向当前正在执行的指令地址再加上2条指令的地址，即指向正在执行指令的下下一条指令，而不是指向下一条要执行的指令。 5. 简述ARM处理器中在线仿真器模块EmbeddedICE-RT的作用。   答：ARM处理器中的在线仿真器模块EmbeddedICE-RT，一般还带有嵌入式宏跟踪单元模块ETM，实现ARM处理器的在线调试和运行过程的跟踪功能；并且具有诸多ICE功能，例如实时寻址、断点、单步、对ARM CPU的完全控制、对ASIC系统其余部分的访问，以及对主机显示器外设访问、键盘输入和磁盘存储。 6. ARM处理器的工作状态分为哪二种？ARM处理器又是怎么定义和标志的？   答：ARM处理器的工作状态分为ARM状态和Thumb状态，这两种状态有程序状态字CPSR中T标志位确定，为0时处理器工作在ARM状态，为1时处理器工作在Thumb状


态。 7. ARM7TDMI支持哪几种指令集，各有什么特点？   答：ARM7TDMI处理器内核包含2套指令系统，分别为ARM指令集和Thumb指令集，两种指令集的特点是：      ARM指令集：处理器执行32位字对齐方式的ARM指令，每条ARM指令长度为32位，指令的功能强大。      Thumb指令集：处理器执行16位字对齐方式的Thumb指令，每条Thumb指令长度为16位，是ARM指令功能的子集。 8. ARM7处理器有哪些工作模式？如何实现不同模式之间的切换？举例说明。   答：ARM处理器供支持7种工作模式，分别为：用户模式（usr）；快速中断模式（fiq）；外部中断模式（irq）；管理模式（svc）；数据访问终止模式（abt）；系统模式（sys）；未定义指令中止模式（und）。在7中模式中，除用户模式外，其他的6种模式称为特权模式，特权模式可以自由的切换处理器模式，而用户模式不能直接切换到别的模式。特权模式下通过修改当前程序状态寄存器CPSR中控制位M[4:0]的值，来改变处理器的运行模式。 例如   MSR   CPSR_c，#（NoInt |SVC32Mode）//从系统模式切换到管理模式   MSR   CPSR_c，#（NoInt |SYS32Mode）//从管理模式切换到系统模式 9. 描述ARM7处理器的内部寄存器结构，并分别说明快速中断FIQ有何特点？   答：ARM7微处理器共有37个32位寄存器，其中31个为通用寄存器，6个为状态寄存器。37个寄存器定义如下： ⑴ 31个通用寄存器：R0~R15、R8_fiq、 R9_fiq、 R10_fiq、 R11_fiq、 R12_fiq、 R13_fiq、 R14_fiq、R13_svc、R14_svc、R13_abt、R14_abt、R13_und、R14_und、R13_irq、R14_irq。 ⑵ 6个状态寄存器：CPSR、SPSR_abt 、SPSR_svc 、SPSR_irq 、SPSR_fiq、 SPSR_und。 快速中断FIQ，适用于对一个突发事件的快速响应，在ARM状态中，快中断有8个专用的寄存器，可以缩短状态切换时需要的时间。当CPSR中相应的F位清零，快速中断被使能。 10. 什么是中断延时？在实时系统中如何计算中断延时时间？   答：中断延时是系统响应一个中断所需要的时间，即从外部中断请求信号发出到执行对应的中断服务程序ISR的第1条指令所需要的时间。      FIQ的中断延时计算，当FIQ使能时，最坏的延时包括： a) Tsyncmax:请求通过同步器的最长时间，为两个处理器周期。 b) Tldm：最长执行时间，最长为20个周期。 c) Texc：数据中止异常进入时间，为三个周期。 d) Tfiq：FIQ进入时间，为两个周期 总的延时可为27个周期。 11. 在内存的数据存储过程中，什么是“字对齐”和“半字对齐”？   答：在内存数据存储过程中，一般分为小端存储格式和大端存储格式。下面以小端存储格式为例来说明字对齐和半字对齐：      在小端存储格式中，对于地址为A的字单元，其中字节的低位字节到高位字节地址顺序为A ，A+1 ，A+2，A+3；对于地址为A的半字单元，其中字节的低位字节到高位字节地址顺序为A ，A+1。 12. 简述程序计数器（PC）在处理器工作中的作用。 


  答：在ARM处理器中将PC程序计数器定义到R15寄存器，无论处理器处于何种状态，PC总是指向D正在取值‖指令的地址。 13. 简述ARM处理器中的返回链接寄存器（LR）在处理器工作中的作用。   答：链接寄存器LR用于保存子程序返回地址或者异常处理程序的返回地址，LR寄存器一共有6个，其中子程序的返回地址使用一个R14，每种异常模式各自有一个专用的LR寄存器用于保存异常处理程序的返回地址，它们分别为R14_fiq、R14_svc、R14_abt、R14_und、R14_irq。 14. 分别简述ARM处理器中的CPSR、SPSR在处理器工作中的作用。   答：ARM内核包含1个CPSR和5个仅供异常处理模式使用的SPSR。      由于所有模式全部共享一个程序状态寄存器CPSR，因此处理器所有的状态全部都保存在CPSR中，也就是ARM内核是通过CPSR来监视和控制内部操作的。      每种异常模式都有一个对应的程序状态保存寄存器SPSR，用于保存任务在异常发生之前的CPSR状态的当前值。 15. 结合CPSR的结构，说明程序状态字中各个bit位的作用。 NZCVI----------FTM4M3M2M1M03130292827876543210答：⑴条件代码标志（共计4bit）含义如下： N：运算结果的最高位反映在该标志位。对于有符号二进制补码，结果为负数时N=1，结果为正数或零时N=0； Z：指令结果为0时Z=1（通常表示比较结果D相等‖），否则Z=0； C：当进行加法运算，最高位产生进位时C=1，否则C=0。当进行减法运算(包括CMP 指令)，最高位产生借位时C=0，否则C=1。 V：当进行加法/减法运算，并且发生有符号溢出时V=1，否则V=0，其它指令V不变。 ⑵CPSR的最低8位为控制位，控制了处理器的工作方式。当发生异常时，这些位被硬件改变。当处理器处于一个特权模式时，可用软件操作这些位。它们分别是： 中断禁止位包括I和F位： 当I位置位时，IRQ中断被禁止； 当F位置位时，FIQ中断被禁止。 T位反映了处理器的当前状态： 当位T=1时，处理器正在Thumb状态下运行； 当位T=0时，处理器正在ARM状态下运行。 模式位包括M[4:0]共计5bit，这些位决定处理器的操作模式 16. 简述ARM7TDMI内部有哪些寄存器及特点。   答：ARM7微处理器共有37个32位寄存器，其中31个为通用寄存器，6个为状态寄存器。37个寄存器定义如下： ⑴ 31个通用寄存器：R0~R15、R8_fiq、 R9_fiq、 R10_fiq、 R11_fiq、 R12_fiq、 R13_fiq、R14_fiq、R13_svc、R14_svc、R13_abt、R14_abt、R13_und、R14_und、R13_irq、R14_irq。 ⑵ 6个状态寄存器：CPSR、SPSR_abt 、SPSR_svc 、SPSR_irq 、SPSR_fiq、 SPSR_und。 特点：在ARM状态中，R0~R7是通用寄存器，是不分组寄存器；R8~R14，SPSR根据


模式进行分组的寄存器；R15是程序计数器，不进行分组；CPSR是状态寄存器，不进行分组。 17. 什么是ARM处理器的异常？ARM处理器中有哪几种异常？   答：在ARM中，异常是一些事件，这些事件能导致正常的程序执行流程被暂时地停止，而进入到该事件对应的处理器异常模式并对该事件进行处理。 ARM中定义了复位、未定义指令、SWI（软中断）、预取指终止、预取数终止、irq以及fiq等７种异常，与之对应地ARM7处理器有5种异常模式。 18. 分别简述ARM7的IRQ、FIQ异常处理过程，说明其异常向量地址。   答：IRQ异常的处理流程如下：  ⑴ 进入IRQ异常模式。程序运行在用户模式下，当一个IRQ异常中断发生时，内核切换到D中断模式‖，并自动的做如下处理。 ①将异常处理程序的返回地址保存到异常模式下的R14(R14_irq)中。 ②用户模式的CPSR将被保存到中断异常模式SPSR_irq中。 ③修改CPSR，将I置1，禁止新的IRQ中断产生，但不改变F值，不限制FIQ中断发生，清零T标志位，进入ARM状态，修改模式位，设置为IRQ模式。 ④将IRQ异常中断入口向量地址0x00000018送入PC。 ⑤在IRQ模式下，用户模式的R13和R14将不能操作，而R13_irq和R14_irq可以操作，即R13_irq保存IRQ模式下的地址指针，R14_irq保存了DIRQ中断返回地址+4‖。 ⑵  退出IRQ异常模式。中断服务程序执行完毕后，使用一条指令将返回地址送入PC，即可实现IRQ中断返回，在返回过程中处理器会自动将SPSR_irq中的内容复制到CPSR，恢复中断前的处理器状态。 FIQ异常进入与退出的流程与IRQ类似，其异常入口地址是0x0000001C。 19. ARM7处理器对哪些异常可以进行屏蔽？如何屏蔽或允许？    答：FIQ和IRQ可以被屏蔽。将CPSR的标志位I和F分别置位对应着IRQ和FIQ中断被禁止，清零这些位又可以将其使能。 20. 说明CPSR中T位的作用，ARM7处理器如何切换状态？   答：CPSR中T标志位为0时处理器工作在ARM状态，为1时处理器工作在Thumb状态。由于ARM采用字对齐或者半字对齐的存储模式，这意味着地址的最低一个比特位就不会在寻址过程中使用到。故，使用地址的最低位进行区分，以何种模式取值和执行指令，当地址地位为1时，置CPSR的T位为1，反之，置位为0。 21. 大端存储模式和小端存储模式的含义是什么？画出在0x2000单元中存储0x87654321数据的大端存储模式和小端存储模式。   答：大端存储模式：在大端存储格式中，对于地址为A的字单元，其中字节的低位字节到高位字节地址顺序为A+3，A+2，A+1，A；对于地址为A的半字单元，其中字节的低位字节到高位字节地址顺序为A+1，A。即数据的低字节存放在高地址中的顺序进行存储。      小端存储模式：在小端存储格式中，对于地址为A的字单元，其中字节的低位字节到高位字节地址顺序为A ，A+1 ，A+2，A+3；对于地址为A的半字单元，其中字节的低位字节到高位字节地址顺序为A ，A+1。即数据的高字节存放在高地址中的顺序进行存储。       0x21 0x43 0x65 0x87   0x21 0x43 0x65 0x87   0x2003 0x2000 0x2000 0x2003 


上图中，左侧为大端存储模式，右侧为小端存储模式。 习题3 1、 ARM7TDMI支持哪几种指令集，各有什么特点？ 答：支持ARM指令集和Thumb指令集，各自特点是ARM指令集的指令是32位，执行效率高、功能全，每条指令可以根据条件执行，但是代码密度低。Thumb指令集指令是16位，在功能上是ARM指令集的子集，功能并没有降低。 2、 ARM指令的寻址方式有几种？并指出下列指令中的寻址方式。 答：ARM指令的寻址方式有8种，分别为立即寻址、寄存器寻址、寄存器移位寻址、寄存器间接寻址、基址变址寻址、相对寻址、多寄存器寻址、堆栈寻址。 ⑴ SUB  R0, R1, R2 寄存器寻址   ⑵ LDR  R0, [R2]   寄存器间接寻址 ⑶ MVN  R0, #0x0F2  立即寻址      ⑷ LDMIA  R0, {R1-R5} 多寄存器寻址  ⑸ STR  R2, [R4, #0x02]！ 基址变址寻址 ⑹ LDR  R1, [R2, R3]   基址变址寻址 ⑺ MOV  R1, R1, ROR #2  寄存器移位寻址   ⑻ LDR  R1, [R3], #0x04   基址变址寻址 3、 简述ARM指令集中第2个操作数（operand2）的三种形式。 答： ⑴ 常数表达方式。该常数必须对应8位位图，即常数是由一个8位的常数循环右移偶数位得到。例如：MOV  R2，#100；    ⑵ 寄存器方式。Operand2是Rm寄存器方式，在寄存器方式下操作数即位寄存器中的数值。例如：SUB R0，R1，R2； ⑶ 寄存器移位方式。Rm，shift 表示将寄存器的移位结果作为操作数，但Rm值保持不变。例如：MOV  R0，R1，RRX；将R1带扩展的循环右移1位，存入R0中。 4、 指出下列指令是否正确，若不正确请说明原因。 ⑴ MOVS  R1, 101 不正确，立即寻址方式应该是#101 ⑵ MVN  R1, #0x10F  正确 ⑶ STMDA  R11, {R2-R8}!  不正确，不能同时存储在R2和R8中  ⑷ ADD  R0!, R2, #4  正确 ⑸ LDR  R4, [R5]!  不正确，LDR是存储到单个寄存器的加载指令，而这个是两个存储器都进行存储，应该为  LDR  R4, [R5] ⑹ MRS  PC, CPSR  不正确MRS是将CPSR传送到通用寄存器中，但这里的通用寄存器不包括R15，即PC ⑺ LDMFDS  R0!, { R5-R8, R2}  正确 ⑻ ADD  R3, [R3], R7  不正确，ADD指令不能访问存储器 (9) LDR  R11, [R15，R8] !  正确     (10) BXS  R0  正确 5、 何谓ARM指令的条件码？默认的条件码是什么？举例说明ARM指令的条件码对指令执行的影响。 答：所谓的ARM指令的D条件执行‖是指在指令码中含有本条指令的执行条件，当CPSR中的条件码标志满足时，处理器执行本条指令，否则本条指令不执行。默认是无条件执行。 比如执行指令“ANDEQ R2，R1，R3”时，如果CPSR中的Z=1时，执行R2=R1&R3，


否则不执行该指令。 6、 解释“满堆栈”、“空堆栈”、“递增堆栈”和“递减堆栈”? ARM指令系统中是如何支持的？ 答：满堆栈：堆栈指针SP指向最后压入的堆栈有效数据项。 空堆栈：堆栈指针SP指向下一个待压入数据的空位置。 递增堆栈：向高地址方向生长。 递减堆栈：向低地址方向生长。 ⑴满递增：堆栈向上增长，SP指向内含有效数据项的最高栈单元。指令如LDMFA、STMFA等；  ⑵空递增：堆栈向上增长，SP指向堆栈上的第一个空位置。指令如LDMEA、STMEA等；  ⑶满递减：堆栈向下增长，SP指向内含有效数据项的最低栈单元。指令如LDMFD、STMFD等； ⑷空递减：堆栈向下增长，SP指向堆栈下的第一个空位置。指令如LDMED、STMED等。  7、 试说明MOV指令、LDR加载指令和LDR伪指令三者的区别。 答：MOV指令是在寄存器间进行数据传送，影响标志位。 LDR指令是将存储器中的数据按给定地址加载到寄存器中，不影响标志位。 LDR伪指令是可以在一个立即数前面加等号，把一个地址写入某寄存器。 8、 解释B指令、BL指令与BX指令的功能差别，并举例说明其使用方法。 答：B指令是分支指令，BL指令是带链接的分支指令，BX是带状态切换的分支指令。对于B指令“B WAITA”指跳转至标号WAITA处开始执行，B指令的跳转范围为±32M，对于BL指令，实现程序跳转，并保持PC到链寄存器LR中，跳转范围±32M，举例“BL DELAY”完成的跳转至标号DELAY处执行，并把PC-4存入LR。BX指令，带状态切换的跳转，比如“BX R0”表示跳转R0指定的地址开始执行，并查看R0[0]位的值，如果是1，对CPSR的T位置位，解释目标程序为Thumb指令，如果是0，对CPSR的T位清零，解释目标程序为ARM指令。 9、 分析下列两段程序片断的功能，试用类C语言写出其等价功能。     答：     10、 使用ARM汇编指令的条件执行功能，试用汇编语言实现下列两条C代码语句。     答：   程序片断1： CMP R0, R1    ADDHI R0 , R0 , #1  ADDLS R1 , R1 , #1 程序片断2： CMP  R0 , #10    CMPNE   R1 , #20    ADDNE R0 , R0 , R1 ⑴ if(x = = y)   a = b + c; else  a = b C c; ⑵ if(x = = y) && ( a = = b) c = c * 2+b; （1） if(R0 > R1)  R0++; else  R1++; （2）if((R0 != 10)&&(R1 != 20))  RO = R0+R1; （1） LDR  R0,x LDR  R1,y LDR  R2,b LDR  R3,c 
 R0,R1 
 R4,R2,R3 
 R4,R2,R3 （2）  LDR  R0,x LDR  R1,y LDR  R2，a LDR  R3，b LDR  R4，c CMP  R0，R1 CMPEQ  R2，R3, MULEQ  R4，R4，#2 
，R4，R3 


   11、 下列代码段是实现开IRQ中断和关IRQ中断功能，试补齐空白处内容。     12、 如果ARM处理器中各寄存器及存储单元参数如下图所示，试写出执行下列指令后，各寄存器及存储单元中内容变化情况。 ⑴ STMIA R13!,{R0-R3}     ⑵LDMDB R13, { R0-R3} 答：     习题4 1. 什么是计算机语言？一般可以分为哪几种？各自的优缺点？ 答：计算机语言是计算机可以识别、理解的语言。计算机语言分为三类：机器语言，汇编语言和高级语言。 机器语言（Machine Language）是由0和1二进制代码表示和存储的指令与数据。它的特点是能被机器直接识别与执行；程序所占内存空间较少。其缺点是难认、难记、难编、易错。 汇编语言是一种面向物理层操作的计算机语言。不同的处理器类型，具有不同的汇编语言。使用汇编语言编写程序能够直接利用硬件系统的特性（如寄存器、标志、中断系统等），可直接对位、字节、字寄存器或存储单元、I/O端口进行处理，同时也能直接使用CPU指令系统提供的各种寻址方式，编制出高质量的程序，这样的程序不但占用内存空间少，而且执行速度快。 缺点：由于汇编语言不直接支持复杂的抽象数据类型，在描述目标系统模型时，需要程序员自己组织各种抽象数据类型的存储方式，使得汇编语言程序设计较高级语言困难的多，需要较多的软件开发时间，也增加了程序设计过程中出错的可能性，程序维护也麻烦。 高级语言（High Level Language）是脱离具体机器（即独立于机器）的通用语言，不依赖于特定计算机的结构与指令系统。与目标系统的数学模型之间有着良好的对应关系，可在各种机器上通用，具有很好的通用性和可移植性。缺点：处理器是不能直接执行这种用高级语言编写的源程序，需要先将它翻译成对应的目标程序（即机器语言程序），才能运行。 2. 简述ARM汇编语言上机操作过程。 答：⑴设计、编辑汇编语言源程序； ⑵汇编、连接、下载到目标系统； ⑶调试运行； 3. 简述编写一个汇编语言源程序的基本步骤。 答：⑴ 分析目标系统，建立数学模型，确定算法 ⑴  MRS  R0，CPSR BIC    R1，R0，0x80  MSR  CPSR_c, R1 ⑵ MRS  R1，CPSR ORR   R1, R1,#0x80 MSR  CPSR_c, R1 (1), [R13]←R0 [R13+4]←R1 [R13+8]←R2 [R13+12]←R3 (2), R0←[R13],R1←R1+4; R1←[R13],R1←R1+4; R2←[R13],R1←R1+4; R3←[R13],R1←R1+4;  


⑵ 根据算法设计流程图 ⑶ 合理分配寄存器，存储空间和外设资源 ⑷ 根据流程图编写源程序 ⑸ 上机调试程序 ⑹ 形成文档 4. 循环程序设计中，循环的基本结构有几种？其循环控制方法有几种？各自的应用特点？ 答：循环程序的基本结构： ⑴ 初始化部分：建立循环初始值。 ⑵ 循环体：是循环程序的主体部分。 ⑶ 修改部分：为执行下一次循环而修改某些参数。 ⑷ 控制部分：通过判断循环结束条件是否成立，决定是否继续执行循环。 ⑸ 结束处理部分：对循环结束进行适当处理，如存储结果和打印输出等。     循环程序设计中一个重要环节就是如何控制循环次数。循环控制方法：⑴ 用计数控制循环。特点：循环比较次数是已知的，因此可以用计数器控制循环。 ⑵ 用条件控制循环。有些情况无法确定循环次数，但循环结束的条件是已知的，这时可通过循环测试结束条件是否满足的方法，条件满足结束循环，否则继续循环。 5. 汇编子程序传递参数有哪几种方式？ 答：⑴ 寄存器传递参数方式 ⑵ 存储区域传递参数方式 ⑶ 堆栈传递参数方式 6. C语言和ARM汇编语言进行程序编制时常用的开发方法有哪些？ 答：使用C语言和ARM7汇编语言进行程序编制时常用的开发方法：混合编程和交叉编程。 7. 简述APCS规则。 答：⑴ 寄存器使用规则。ARM处理器寄存器组中的{R0-R11}用来保存局部变量；{R12-R15}用于系统专用：R12用于子程序内部调用的片段寄存器；R13当前模式的堆栈指针；R14链接寄存器，保存子程序的返回地址；R15用作程序计数器。其中，由于{R4-R11}用来保存局部变量，对于遵守APCS规则的函数，在进入该函数的时候，程序员必须注意保存{R4-R11}中会被函数使用的寄存器，当返回时，再返回它们的值。 ⑵ 堆栈使用规则。APCS规则中的堆栈为FD类型，也就是满递减堆栈，并且堆栈的操作是8字节对齐的，所以需要在汇编程序中用伪指令PRESERVE8来告诉连接器，本程序使用的堆栈是字节对齐的。 ⑶ 参数传递规则。ARM7处理器寄存器组中{R0-R3}用于程序间的参数传递，其中R0传递第一个参数，R1传递第二个参数，以此类推；如果参数数目超过4个，那么必须使用堆栈进行传递。 8. 实现将某个寄存器中的字数据拆分成4组字节数据的功能。 答：不妨设数据在R0中，拆成的数据存放在R1~R4中，程序代码如下。       MOV  R1,R0 AND  R1,R1,#0xFF ; MOV  R2,R0,LSR 0x08 AND  R2,R2,#0xFF MOV  R3,R0,LSR #0x08 AND  R3,R3,#0xFF MOV  R4,R0,LSR 0x08 AND  R4,R4,#0xFF 
R1~R4的低八位，高24为清零 



   9. 实现统计任意字符串包含的字符个数的功能。（约定：字符串以0为结束标志） 答：             10. 实现10个64位有符号数的相加运算。 答：                    11. 实现如下功能：已知BUF1中有N1个按从小到大顺序排列的互不相等的字符号数，BUF2中有N2个从小到大顺序排列的互不相等的字符号数，将BUF1和BUF2中的数合并到BUF3中，并按从小到大顺序排列且互不相等。 答：   LDR  R0,string; 将一个字符串的地址放到R0中。 MOV  R1,0;    将字符串结束符放R1中 MOV  R3,0;    将统计长度的放入R3中 LDR  R2,[R0];  将字符串的第一个字符放入R2 count: CMP  R2,R1;    将R2中内容与结束符0进行比较 BEQ  next;      如果相等，说明比较结束 ADD  R3,R3,#1;  如果不等长度值加1 LDR  R2,[R0+#1];讲下一个字节装入R2 B  count;        分支结构，返回至比较处，继续比较。 next: ;跳出这个算法的标号  不妨假设这10个64位数紧密排列存储在存储器中，每个64位数占用8个字节的内存空间，按小端模式存放，首地址为sp  LDR     R0,SP; LDR     R1,[R0]; LDR     R2,[R0, #-4]; MOV    R3，#9; count： CMP     R3，#0; BEQ     next; LDR     R4,[R0, #-8]; ADC    R1,R1,R4; LDR    R5,[R0, #-12]; ADD    R2,R2,R5; SUB     R0,R0,#8; SUB     R3,R3,#1 CLR     C; next: 目标达到，10个数相加的结果高32位放在R1中，低32位放在R2中。  AREA COPY,CODE,READONLY     ENTRY     CODE32 start     LDRB R2,=BUF1 



                                             LDRB R3,=BUF2     LDRB R4,=BUF3     LDR R5,=N1     LDR R6,=N2     ADD R5,R5,R6     MOV R1,#0     BL LOOP stop     MOV R0,#0x18     LDR R1,=0x20026     SWI 0x123456 LOOP     CMP R5,R1     BEQ stop     LDRB R0,[R2]     LDRB R6,[R3]     CMP R0,R6     BLS COPY1     BHI COPY2 COPY1     LDRB R0,[R2],#1     STRB R0,[R4],#1     ADD R1,R1,#1     CMP R0,#0     BEQ LOOP COPY2     LDRB R0,[R3],#1     STRB R0,[R3],#1     ADD R1,R1,#1     CMP R0,#0     BEQ LOOP      AREA COPYDATA,DATA,READWRITE BUF1 DCB "whos speaking",0 BUF2 DCB "this is ",0 BUF3 DCB "A", N1 DCD 8 N2 DCD 6  


习题5 1、 什么是存储器映射？简述LPC2000系列处理器中各种资源是如何映射的？   答：将物理存储器分配到逻辑地址的过程称为存储器映射。LPC2000系列处理器中的存储器映射空间范围为：0x00000000-0xFFFFFFFF，起始地址依次为：FLASH―0x00000000，SRAM―0x40000000，BOOTBLOCK―0x7FFFE000，外部存储器0x80000000，VPB（低速外设地址）―0xE0000000，AHB―0xF0000000. 2、 什么是重映射？试分析重映射的原理与实现机制。   答：存储器重映射：将已经映射过的存储器再次映射的过程称为存储器重映射，它使同一物理存储单元映射多个不同的逻辑地址。原理：此时运用了异常向量表重映射技术，就是将Boot Block的0x7FFFE000~0x7FFFE03F，片内SRAM的0x40000000~0x4000003F及片外存储器的0x80000000~0x8000003F向量表分别重映射到0x0000~0x003F地址空间。实现机制：使用存储器映射控制机制来改变0x0000~0x003F区间的中断向量映射关系，比如LPC2000提供了一个存储映射控制寄存器MEMMAP，可以被读写，低两位为00、01、10、11时分别重映射Boot Block、片内Flash、片内SRAM和片外存储器。 3、 什么是中断？叙述中断处理过程。   答：计算机在执行正常程序过程中，当出现某种异常事件或某种外部请求时，处理器就暂停执行当前的程序，而转去执行对异常事件或某种外部请求的处理操作。当处理完毕后，CPU再返回到被暂停执行的程序，继续执行，这个过程称为中断。     中断处理过程一般包括五个步骤：中断请求，中断响应，断点保护，中断处理和中断返回。 4、 ARM7的中断类型有哪些？哪种方式最快？当有多个中断源同时向CPU发出中断申请时，CPU依据什么来进行响应中断？   答：根据中断源的不同，中断可以分为硬件中断和软件中断。有三类：非向量IRQ中断，向量IRQ中断，FIQ中断。它们的优先级依次升高。所以FIQ中断的处理速度最快。       当多个中断源同时向CPU发出中断申请时，CPU只能按一定的次序处理相应和处理，这个响应的次序称为中断优先级。处理原则为： ⑴ 不同优先级的多个中断源同时发出中断请求，按优先级由高到低依次处理。 ⑵ 低优先级中断正在处理，出现高优先级请求，应转去处理高优先级请求，服务结束后再返回原优先级较低的中断服务程序继续执行。 ⑶ 高优先级中断正在处理，出现低优先级请求，可暂不响应。 ⑷ 中断处理时，出现同级别请求，应在当前中断处理结束以后再处理新的请求。 5、 LPC2000系列有那些降低功耗的方法？简述空闲模式和掉电模式的区别。   答：降低功耗的方法有空闲模式和掉电模式。除了采用这两种模式外，还允许程序对某个外设进行关闭控制，可以独立的关闭应用中不需要的外设，这样进一步降低功耗。      空闲模式和掉电模式的区别：在空闲模式下，处理器停止执行指令，此时处理器，存储器，内部总线以及相关的控制器不再消耗功率，但整个系统的时钟仍然有效，外设也能在空闲模式下继续工作，并可产生中断使处理器恢复运行。然而在掉电模式下，振荡器关闭，这样芯片内部没有任何时钟。处理器状态和寄存器，外设寄存器，内部SRAM值以及引脚的逻辑电平在掉电模式下被保持。 6、 简述LPC2000系列中PLL的工作原理，说明系统时钟的配置过程。   答：PLL接受的输入时钟频率范围为10~25MHz，PLL的输出时钟信号是由电流控制振荡器（CCO）分频得到的，CCO的振荡频率由“相位频率检测”部件控制，该部件会比较输


出时钟信号和CCO经过M分频后信号的相位和频率，并根据误差输出不同的电流值以控制CCO的振荡频率，CCO的输出频率经过M分频后再送给“相位频率检测”部件检测以控制CCO的振荡频率，经过反复拉锯调节过程，能够使得“相位频率检测”部件的两路输入信号频率和相位逐步接近，渐渐稳定到预期的频率值上。这种反复拉锯调节过程称为PLL锁定过程，输出频率稳定后即“锁定”成功。 其配置过程： 1.选择处理器的操作频率，选择振荡器的频率，计算M值和P值； 2.配置PLLCON使能但不连接的PLL的模式，根据P和M的值配置PLLCFG寄存器，发送PLL馈送序列，然后等待PLL锁定或中断； 3.连接PLL，发送PLL馈送序列。 7、 简述LPC2000系列芯片内部向量中断控制器（VIC）的功能特点，如果定时器0作为一个向量中断源，需要对VIC进行哪些配置？简述向量处理过程。   答：向量中断控制器（VIC）负责管理芯片的中断源，最多可管理32个中断输入请求，16个向量IRQ中断和1个非向量中断，16个优先级可动态分配给中断请求，可产生软中断。VIC为每一个中断分配中断通道号，通道号就是每一种中断源的唯一标识，中断到来时，根据VIC通道号就能确定中断源。 1.配置中断选择寄存器VICIntSelect，中断通道4分配为IRQ中断； 2.配置寄存器VICVectAddr0，确定定时器0中断的服务程序地址； 3.配置寄存器VICVectCntl0，向量IRQ通道0控制寄存器位分配位数值； 4.配置中断时能寄存器，使能中断。 8、 FIQ、IRQ有什么不同？向量IRQ和非向量IRQ有什么不同？   答：快速中断请求FIQ要求具有最高优先级。 向量IRQ具有中等优先级，该级别可分配32个请求中的16个，32个请求中的任意一个都可分配到16个向量IRQ slot中的任意一个，其中slot（）具有最高优先级，而slot15则为最低优先级。 非向量IRQ的优先级最低。 习题6 1. 简述LPC2000系列芯片的引脚设置寄存器PINSEL0、PINSEL1、PINSEL2的具体功能。 答：这三个寄存器的主要功能是实现对引脚的功能选择。具体来说PINSEL0和PINSEL1可以配置P0口(P0.0~P0.31)的功能，PINSEL2寄存器用来配置P1.0~P1.16引脚的功能。PINSELx的连个比特位可配置一个引脚的功能，比如以PINSEL[1:0]两个比特位的00、01、10可以配置P0.0为GPIO、TxD(UART0)、PWM1，11保留。 2. 简要描述LPC2000系列芯片内部GPIO的功能特点？举例说明GPIO输入和输出的应用。 答：GPIO(General Purpose Input/Output ports，通用输入输出接口)是用于二进制数据的输入和输出。芯片的某个引脚通过MUX1功能选择，对应PINSELx寄存器选择器功能。如果选择该引脚为GPIO那，再经MUX2中的IOxDIR对应位选择控制管脚的输入和输出方向，GPIO管脚为输入时通过IOxPIN寄存器读入，GPIO为输出时通过IOxSET和IOxCLR寄存器控制输出，实现对对应GPIO管脚的控制。 当引脚设置为GPIO输出模式时，使用IOxSET寄存器设置其从引脚输出高电平，向某


位写入1是对应引脚输出高电平，写入0无效；使用IOxCLR寄存器设置从引脚输出低电平，向某位写入0是对应引脚输出低电平。GPIO输入用于向ARM核中读入数据，GPIO输出用于输出数据。 3. LPC2000系列芯片外部中断有几种触发方式？【例6.7】中外部中断修改为EINT1，P0.5输出控制LED，试编程实现。 答：外部中断有两类四种触发方式：边沿触发（上升沿触发或者下降沿触发）,电平触发（高电平触发或低电平触发）。编程实现的代码如下 ：                                  4. 简述LPC2000系列芯片内部定时器的内部由哪些模块构成？各模块完成功能是什么？ 答：定时器内部由三部分组成：分频与计数模块、匹配控制模块和捕获控制模块。 分频计数模块：属于基本模块，提供每个定时器捕获匹配的基本时钟，属于定时器的公共部分，可对外部接入时钟进行预分频。 #include "config.h" #difine LED 1<<5        //设置P0.5控制LED，高电平LED点亮 void__irq URQ_Eint1(void) {    uint32 i;     i = IO0SET;    // 读取LED控制值     if((i&LED)==0)         IO0SET = LED;   // 点亮LED     else         IO0CLR = LED; //  熄灭LED     WHILE((EXTINT &0x02) != 0) //等待EINT1恢复为高电平     {         EXTINT = 0x02;   // 清除EINT1中断标志     }     VICVectAddr = 0; // 向量中断结束 } int main(void) {     PINSEL0 = 0x000000C0;   //设置P0.3为EINT0  IO0DIR = LED;           // 设置P0.5引脚为输出     EXTMODE = 0x00;         // 设置EINT1为电平触发     EXTPOLAR = 0x00;        // 极性寄存器-低电平有效     IO0CLR = LED;            //  设置LED初态为熄灭     VICIntSelect = 0x00000000;     //  设置中断类型为IRQ中断     VICDefVECAddr = (int )IRQ_Eint1; // 装载中断服务程序地址     EXTINT = 0x02;        // 清除EINT1中断标志     VICIntEnable = 1<<15    //使能EINT1     while(1);              //等待中断     return 0; }  


匹配控制模块：比较器随时进行MR0~MR3与TC的匹配，当TC计数值与某一MRx的预置值相等时即执行ＭＣＲ编程的功能。 捕获控制模块：外部触发捕获时，将当前TC值装在如CRx中。 5. 采用匹配中断输出产生周期为1秒的方波。 答：                          6. 通过一个定时器中断控制多个输出接口控制LED灯分别以0.1S、0.5S和1S频率同时闪烁，假设这三种灯分别连接P0.1、P0.2和P0.3，试编程实现上述功能。 答： 程序如下：            #include“config.h” int main(void) {     PINSEL0 = PINSEL0&(~(3<<10))|(2<<10);     T0CTCR = 0x00;     T0TC = 0;     T0PR = 199;     T0MCR = 0x02<<3;     T0MR1 = Fpclk/200;     T0EMR | = 0xC2;     T0TCR =0x01;     while(1);     return 0; }  #include“config.h” #define led1 1<<1     //p0.1控制led1，低电平点亮 #define led2 1<<2     //p0.2控制led2，低电平点亮 #define led3 1<<3     //p0.3控制led3，低电平点亮 void __irq IRQ_Time1(void) {    if((IO0SET&led1)==0)        IO0SET= IO0SET|led1; //关闭led1             else  IO0CLR= IO0CLR&led1;//点亮led1 T0IR=T0IR|0x01;//清除MR0中断标志位 VICVectAddr=VICVectAddr&0x00//通知VIC中断处理结束 } 


                                            void __irq IRQ_Time2(void) {    if((IO0SET&led2)==0)        IO0SET= IO0SET|led2; //关闭led2             else  IO0CLR= IO0CLR&led2;//点亮led2 T0IR=T0IR|0x02;//清除MR1中断标志位 VICVectAddr=VICVectAddr&0x00//通知VIC中断处理结束 } void __irq IRQ_Time3(void) {    if((IO0SET&led3)==0)        IO0SET= IO0SET|led3; //关闭led.3             else  IO0CLR= IO0CLR&led3;//点亮led3 T0IR=T0IR|0x04;//清除MR2中断标志位 VICVectAddr=VICVectAddr&0x00//通知VIC中断处理结束 } int main(void) { PINSEL0=0x00000000;//设置引脚为GPIO   IO0DIR=IO0DIR&led1;//设置led1控制口输出 IO0DIR=IO0DIR&led2; //设置led2控制口输出 IO0DIR=IO0DIR&led3; //设置led3控制口输出 IRQEnable();//IRQ中断使能 T0TC=0;//定时器设置为0 T0PR=0;//时钟不分频 T0MCR=0x01B3;//设置T0MR1，T0MR1，T0MR2匹配后复位T0TC，并产生中断 T0MR0=Fpclk/10;//0.1s定时 T0MR1=Fpclk/2; //0.5s定时 T0MR2=Fpclk; //1s定时 T0TCR=0x01;//启动定时器 VICIntSelect=0x00;//设置所有中断通道为IRQ中断 VICVectCntl0=0x20|0x04;//设置定时器0中断通道分配最高优先级 VICVectAddr0=(uint32)IRQ_Time1; //进入MR0中断 VICIntEnable=1<<0x04; //使能定时器0中断 VICVectAddr0=(uint32)IRQ_Time2; //进入MR1中断 VICIntEnable=1<<0x04; //使能定时器0中断 VICVectAddr0=(uint32)IRQ_Time3;//进入MR2中断 VICIntEnable=1<<0x04;//使能定时器0中断 while(1);//等待中断 return 0; }  


 7. 简述串行通信与并行通信概念。 答：串行通信是指要传输的数据的各个位，逐比特一位一位的传输方式。并行通信是指待传输的数据各位同时进行传输，如同时传输一个字节的数据。 8. 简述同步通信与异步通信概念、区别。 答：异步通信是指，在传输时，必须确定字符格式及波特率，其中包含启停标志。 同步通信是指，去掉异步通信中的启停标志，尽在有效数据块开始除使用1~2个同步字符表示开始。区别主要是，异步通信不要求收发双方的时钟完全同步，同步通信要求实现位同步，同步通信每次传输的数据位数没有限制，效率比异步方式高。  9. 编写一个通用的UART驱动程序。要求： (1) PC作为上位机，运行EasyARM.exe程序，控制LPC2131实验板操作，发送数字控制对应LED亮灭，数码管显示“0～F”，能够实现双方向通信； (2) 使用中断方式接收、发送数据； (3) 要充分利用UART的硬件接收、发送FIFO；                                                 (4) 编写的程序代码要求简洁、高效、可靠； 答：                           #include "config.h" typedef struct UartMode {  uint8 datad;  uint8 stopb;  uint8 parity; }UARTMODE;  uint8 rcv_buf[8]; volatile uint8 rcv_new; void __irq IRQ_UART0(void) {  uint8 i;  if((U0IIR&0x0F)==0x04)   rcv_new=1;  for(i=0;i<8;i++)   rcv_buf[i]=U0RBR;  VICVectAddr=0x00; } void UART0_SendByte(uint8 dat) {  U0THR=dat; }  


                                                void UART0_SendBuf(void) {  uint8 i;  for(i=0;i<8;i++)   UART0_SendByte(rcv_buf[i]);  while((U0LSR&0x20)==0); } int8 UART0_Init(uint32 baud,UARTMODE set) {     uint32 bak;     if((baud==0)||(baud>115200)) return (0);     if((set.datab<5)||(set.datab>8)) return (0);     if((set.stopb==0)||(set.stopb>2)) return (0);     if(set.parity>4) return (0);     U0LCR=0x80;     bak=(Fpclk>>4)/baud;     U0DLM=bak>>8;     U0DLL=bak&0xFF;     bak=set.datab-5;     if(set.stopb==2)     bak |= 0x04; if(set.parity!=0)     {         set.parity-=1;         bak |= 0x08;     }     bak |= set.parity<<4;     U0LCR=bak;     return (1); } int main (void) {        UARTMODE set;     set.datab=8;     set.stopb=1;     set.parity=0;     rcv_new=0;     PINSEL0=0x00000005;     UART0_Init(115200,set);     U0FCR=0x81;     U0IER=0X01;     IRQEnable();     VICIntSelect=0x00000000; 


                    10. 简述SPI接口的工作过程，举例说明如何实现4个SPI接口之间的通信。 答：SPI(Serial Peripheral Inerface,串行外围设备接口)，工作过程是，主机发送数据时，先产生一个选通信号，之后发送数据，从被选通后设备接收到数据线上传送的数据。 4个SPI接口之间的通信，要设置4个选通信号区分这四个SPI接口，在数据发送时，就可以唯一的确定是哪一个设备接收数据。 11. 分析I2C接口如何实现双工通信，从机的芯片选择如何实现? 答：I2C是双线式串行总线，传输方向根据（R/W）状态位进行确定。从机的芯片选择是实现方法是，主机的发送器向从机接收器发送数据，主机发送的第一个字节的高七位是从机的地址，接下来是数据字节流，从机每接受一个字节，就给主机发送一个应答位。 12. 说明A/D转换器的功能，举例说明10位转换器中模拟信号与数字信号之间的对应关系。 答：A/D转换器主要实现把模拟量进行采样形成数字量，以便CPU可以进行处理。在10位转换器中，模拟信号被采样之后形成10个比特位的数字信号。 13. 论述为什么在实时系统中要使用看门狗，喂狗时间如何确定？ 答：在嵌入式应用中，CPU必须可靠的工作，即使因为某种原因进入了一个错误状态，系统也应该可以自动恢复。看门狗的用途就是使微控制器在进入错误状态一段时间内进行复位。WTD看门狗部件中包含一个带预分频器的可编程32位定时器，用这个定时器可以设定这一等待时间。喂狗时间要求在定时等待时间内，向WDFEED寄存器中装入0xAA，然后写入0x55，此时定时器的WTC重新装入。      VICIntSelect=0x00000000;     VICVectCntl0=0x20|0x06;     VICVectAddr0=(uint32)IRQ_UART0;     VICIntEnable=1<<0x06;     while(1)     {         if(rcv_new==1)         {             rcv_new=0;             UART0_SendBuf();         }     }     return 0; }  